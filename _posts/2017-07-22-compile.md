---
layout: detail
title: 基本功之编译器的锤炼（零） 【统筹篇】
tags: 基础
categories: 编程语言 原理
---

* TOC
{:toc}

# 序言
我们和电脑或者其它机器打交道，往往不在一个频道上面。究其原理，就是运作的方式不同，物质基础不一样，所以对于信号的处理方式有所不同。机器对于信号的识别和处理方式是先转成符合他的形式，然后进行动作。笔者这里把 **编译** 的概念泛化，认为 **编译器** 就像是不同世界架起的 **桥梁** 。<br />
我们都知道，当代的电子计算机是走电的【量子计算机，生物计算机就不清楚了】。计算机的运行，无非是对于一串有规律的电流，硬件有一套响应机制，这些器件会体现出来，软件无非是告诉硬件这些规律【笔者瞎理解的】。而机器对这些规律的直接理解就是二进制【电平高低电位】，然而二进制反人类，人类根本没法去制造规律【编码】，所以出现了汇编语言，把二进制的指令集用符号替代。因此，看待汇编就像看待二进制，任何语言，任何和计算机或者电子仪器交流的信息都需要转成对应的汇编指令，而这个转换的过程就是编译的过程【然而却不是全等的，因为高级语言之间也可以互转，但是最终要机器执行，必须转汇编（等同二进制）】。所以笔者认为，**基本功**里面 **汇编** 和 **编译** 是很重要的两块，其中在对编译器的理解和锤炼过程中，能够连接高级语言与计算机之间的桥梁，就像打通任督二脉一样舒服。<br />
瞎哔哔完毕，现在就走向编译原理的修炼之路吧。<br />

本篇既然叫统筹篇，那么有必要上个蓝图【← _ ← ... 寻找宝藏，得有个地图吧】：
~~~
                -----------------                 -------------------------                  ---------------------------------
>>>修炼历程>>>>>>   编 译 原 理    >>>>修炼历程>>>>>    编译器分析【各种语言】  >>>>>修炼历程>>>>>    打造编译器【自己】 >>>>> ....     
                -----------------                 -------------------------                  ---------------------------------
~~~

# 大纲
笔者一直认为，**原理** 和 **基础** 的东西比起流行的技术或框架往往更不会过时，考验的是基本功，因此，熟读编译原理和精通编译器，必定能练成绝世神功。
<br />
**编译器** 就是将 **一种语言** 翻译成 **另一种语言** 。整个过程是很复杂，而且不同编译器是有类似的地方的，为了复用和方便理解，一般将编译器分为前端和后端，我们的修炼之旅就是从前端到后端，从原理到现有的编译器分析。<br />
本文旨在全面概述编译器的制作原理，以及涉及的相关概念。

## 定义

先来个官方定义【来自维基百科】：
~~~
编译器【Compiler】，是一种计算机程序，它会将用某种编程语言写成的源代码【原始语言】，转换成另一种编程语言【目标语言】。
~~~

一些概念
~~~
源程序：用汇编语言或者高级语言编写的程序。
目标程序：用目标语言所表示的程序。
目标语言：可以是介于源语言和机器语言之间的“中间语言”，【可以是某种机器的机器语言，也可以是某种机器的汇编语言】。
翻译程序：将源程序转换为目标程序的程序。【它是指各种语言的翻译器，包括汇编程序和编译程序，是汇编程序、编译程序以及各种变化程序的总称】。
汇编程序：若源程序用汇编语言编写，经过翻译程序得到用机器语言表示的程序，这时的翻译程序就称为汇编程序，这种翻译过程称为“汇编”【assemble】。
编译程序：若源程序是用高级语言书写，经过加工后得到目标程序，这种翻译过程叫做“编译”【compile】。
解释程序：把源程序作为输入，但不产生目标程序，而是边解释边执行源程序本身。
~~~

## 解析
### 编译器的执行原理
~~~
              ---------            ---------              ---------              --------------                   -----------------                   -----------                   ----------------
→→--字符流--→ |词法分析| →--符号流--→|语法分析| →--语法树--→ |语义分析| →--语法树--→ |中间代码生成器| →--中间表示形式--→ |机器无关代码优化| →--中间表示形式--→ |代码生成器| →--目标机器语言--→ |机器相关代码优化| →--目标机器语言--→→
              ---------            ---------              ---------              --------------                   -----------------                   -----------                   ----------------
~~~

### 各阶段过程概述
~~~
第一阶段：词法分析【lexical analysis】
   · 任务
       输入源程序，对构成源程序的字符串进行扫描和分解，识别出一个个单词。
       > 保留字【关键字（begin，end，if，for，while等等）】
       > 标识符【变量名】
       > 常数
       > 算符
       > 界符
   · 工具
       > 正规式
       > 有穷自动机

第二阶段：语法分析【syntax analysis】
   · 任务
       根据语言的语法规则，把单词符号串分解成各类语法单位【语法范畴】，如：
       > 短语
       > 子句
       > 句子【语句】
       > 程序段【程序】
  · 准则
       > 语法规则【通常是上下文无关文法】

第三阶段：语义分析【semantic analysis】 和 中间代码生成【intermediate generator】
   · 任务
       对语法范畴，分析含义，产生中间代码【初步翻译（一种含义明确，便于处理的记号系统，独立于硬件；与机器指令很相近，很容易转变）】
   · 中间代码详解
       > 三地址码
         - 语法
           [操作码] [操作数1], [操作数2]
       > 四元式【三地址码等价表示式】
         - 语法
           [操作码, 操作数1, 操作数2, 结果]
       > 间接三元式
         - 语法【间接码表 + 三元式表】
           -> (1) -> (2)【操作码 操作数1（步骤序） 操作数2（步骤序）】 -> (3)【操作码 操作数1（步骤序） 操作数2（步骤序）】 -> (n) ...
         - 示例【
               X := (A + B) * C;
               Y := D ^ ( A + B );
             】
                                    |              三元式表
                   间接码表          |--------------------------------------------------------------
                                    |   序号  | 操作码 | 操作数1 | 操作数2
          -----------------------------------------------------------------------------------------
                                    |   (1)   |   +   |   A     |    B
                X := (A + B) * C    ---------------------------------------------------------------
                (1)(2)(3)           |   (2)   |   *   |  (1)    |    C
                                    ---------------------------------------------------------------
          --------------------------|   (3)   |   :=  |   X     |   (2)
                                    ---------------------------------------------------------------
                Y := D ^ ( A + B )  |   (4)   |   ^   |   D     |   (1)
                (1)(4)(5)           ---------------------------------------------------------------
                                    |   (5)   |   :=  |   Y     |   (4)
          -----------------------------------------------------------------------------------------
       > 逆波兰式【后缀表达式】
        - 语法
          [操作数1 操作数2 操作符]  
       > 树形表示
       > ...

第四阶段：优化【Optimization】
    · 任务
        对产生的中间代码进行加工和变换，以期望能得到更为高效的目标代码。【一般包括：公共子表达式的提取，循环优化，删除死代码。（并行化处理）】
    · 原则
        程序等价变化规则

第五阶段：目标代码生成【Code Generation】
    · 任务
       把中间代码【或者优化处理后】变换成特定机器上的低级语言代码。
    · 示例
       > 中间代码
           (*, id3, 10.0, t1)
           (+, id2, t1, id1)
       > 目标代码
           MOV id3, R2
           MUL #10.0, R2
           MOV id2, R1
           ADD R1, R2
           MOV R1, id1

ps. 并不是所有的编译程序都要分为这五个阶段，根据需求来。
    > 不需要优化
          优化阶段可省去
    > 加快编译速度
          中间代码生成阶段可省去


======================================================================================================================================
有图走遍天下
======================================================================================================================================
                                  ↓
                        【源程序】 ↓
          ↓ ← ← ← ← ← ← ←  词法分析器【扫描器】 → → → → → → → → ↓
          ↓         【单词符号串】 ↓                           ↓
          表 ← ← ← ← ← ← ←  语法分析器【分析器】→ → → → → → → → 出
          格          【语法单位】 ↓                           错
          管 ← ← ← ← ← ←  语义分析和中间代码生成器 → → → → → →  管
          理        【中间代码串】 ↓                           理
          ↓   ← ← ← ← ← ← ←   代码优化器  → → → → → → → → → →  ↓
          ↓         【中间代码串】 ↓                           ↓
          ↓   ← ← ← ← ← ← ←   代码生成器  → → → → → → → → → →  ↓
                  【目标代码程序】 ↓
                                  ↓

~~~


## 求索
在高级语言发展的早期，这些程序设计工具往往是独立的，缺乏整体性，而且也缺乏对软件开发全生命周期的支持。随着软件的发展，现在人们越来越倾向于构造集成化的程序设计环境。

· 编译器的发展史
~~~
1950 year
     John Backus FORTRAN语言及其编译器进行开发
     Noam Chomsky 开始了对自然语言的研究
     有限状态自动机【Finite Automaton】
     正则表达式【Regular Expression】

60 和 70 年代
    分析问题【Parsing Problem，用于识别上下文无关文法识别的有效算法】
    分析程序生成器【Parser Generator，能够自动处理编译的一部分】

70年代后期 和 80年代早期
    大量项目都贯注于编译器其他部分的生成自动化【其中包括代码生成】。

90年代
    作为GNU项目，或者其他开源项目的一部分，许多免费的编译器和编译器开发工具被开发出来，这些工具可以用来编译所有计算机的程序语言。

...

~~~

## 用途
~~~
> 可以对高级语言运作的原理深入理解
> 是不同编程语言互通的桥梁
> ...
~~~

# 总结
**编译程序**，无疑是 **实现高级语言的一个最重要的工具**。在着手构造一个编译器时，需要预先考虑种种因素【诸如，系统功能要求，硬件设备，软件工具等等】，**特别是** 必须估量所有这些因素对编译器的影响。因此，**编译器的锤炼** 是一个困难又具有挑战的工作，它要求 **不仅对底层的深入理解，还需要对上层思想和算法精通的能力**。


↓
→ 简而言之，**编译器** 是一个对 **输入流** 进行 **转换与适配** 并 **输出目标流** 的 **工具**。


**（以上，仅代表个人观点。无论对错，欢迎交流。^_^ ）**




[cffxq]:{{ "/2017-07-22-cffxq.png" | prepend: site.imgrepo }}
