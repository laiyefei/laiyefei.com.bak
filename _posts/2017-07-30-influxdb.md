---
layout: post
title: 迈出DBA之路（三）学学InfluxDB
tags: GoLang 大数据 NewSQL 分布式
categories: 数据库
---

* TOC
{:toc}

# 序言
今天笔者去看了看七牛云在厦门主办的大数据应用场景的技术沙龙，对于大数据的架构有了更加深入的理解，同时，又对自己的知识面狭窄感到无奈，话不多说，赶紧学习起来了。一步一个脚印，今天来学一学InfluxDB。<br />

# 大纲
**DBA** 在笔者的印象中，就是管理数据库的，那么与数据库有关的东西，笔者感觉都属于DBA的范畴，所以，笔者把InfluxDB也当作DBA的之路中的一步了。

## 部署
笔者懒得去装环境了，就用windows子系统示例了【ubuntu】：
~~~
1. wget https://dl.influxdata.com/influxdb/releases/influxdb_1.3.1_amd64.deb
2. sudo dpkg -i influxdb_1.3.1_amd64.deb
3. sudo service influxdb start【启动数据库】
【注. MD5：f97087ec2b9c83c69ef246bd2f14ac6f】
~~~

## 定义
**InfluxDB** 是 **Go语言** 写的一个 **开源分布式** **时序**、**事件** 和 **指标** **数据库**。它是用 **NewSQL** 语言进行交互的，本质上属于关系型数据库的一种，但是区别于传统的关系型数据库。


## 解析
笔者一般会去扒源码，但是精力有限，暂时还没用到这个数据库，就先了解下，以后业务需求再深入研究了。

### 概念转换
~~~

      OldSQL数据库           |         InfluxDB
----------------------------+---------------------------------------------
      数据库                 |      database
----------------------------+---------------------------------------------
      数据库中的表           |      measurement
----------------------------+---------------------------------------------
      表内的行数据           |      points
----------------------------+---------------------------------------------

· point 详解
      point属性             |      OldSQL数据库概念
----------------------------+---------------------------------------------
      time                  |      每个数据的记录时间【主索引（自动生成）】
----------------------------+---------------------------------------------
      fields                |      各种字段的记录值【没有索引属性】
----------------------------+---------------------------------------------
      tags                  |      各种字段的记录值【有索引属性】
----------------------------+---------------------------------------------
ps. series【语法：show series from [表名]】：通过tag排列组合将数据展示成图表。

~~~

### 基本操作

#### 用户管理
~~~
1. 显示用户 show users
2. 创建用户 create user [用户名] with password [密码]
3. 创建管理员权限的用户 create user [用户名] with password [密码] with all priveleges
4. 删除用户 drop user [用户名]
~~~

#### 数据库操作
~~~
1. 显示数据库
   show databases

2. 新建数据库
   create database [数据库名]

3. 删除数据库
   drop database [数据库名]

4. 使用数据库
   use [数据库名]
~~~

#### 数据表操作
~~~
1. 显示所有表
   show measurements

2. 新建表
   insert [表名], [字段名1]=[值1], [字段名2]=[值2], ...【tags】 [字段名1]=[值1], [字段名2]=[值2], ...【fields】
   【注：不存在直接建表的操作，代之的是：插入数据元，就会新增一张表】

3. 删除表
   drop measurement [表名]
~~~

#### 数据元操作
~~~
1. 插入数据
   · 命令行【NewSQL语法】
         use [数据库]
         insert [表名], [字段名1]=[值1], [字段名2]=[值2], ...【tags】 [字段名1]=[值1], [字段名2]=[值2], ...【fields】

   · 通过启动后的api
         curl -i -XPOST 'http://localhost:8086/write?db=[数据库名]' --data-binary '[表名], [字段名1]=[值1], [字段名2]=[值2], ...【tags】 [字段名1]=[值1], [字段名2]=[值2], ...【fields】'

2. 删除与修改【数据保存策略（Retention Policies）；InfluxDB 没有提供向OldSQL那样的删除和修改，取代的是数据保存策略】
   · 查看当前数据库的数据保存策略【Retention Policies】
         show retention policies on [数据库名]
   · 创建新的数据保存策略
         create retention policy [策略名] on [数据库名] duration [时间]【例：30d（h小时，w星期，d天，m分钟）】 replication 1【副本个数】 default【默认策略】
   · 修改数据保存策略【Retention Policies】
         alter retention policy [策略名] on [数据库名] duration [时间]【例：30d（h小时，w星期，d天，m分钟）】 default【默认策略】
   · 删除数据保存策略【Retention Policies】
         drop retention policy [策略名] on [数据库名]
   【ps. 设置策略，过期数据就删除了（因为是时序的，所以更新基本用不到，再说了，删除插入就是更新啦）】

3. 查询
   · 命令行
         use [数据库名]
         select * from [表名] order by time desc limit [n] 【查询最新的n条记录】
   · 通过http接口
         curl -G 'http://localhost:8086/query?pretty=true' --data-urlencode "db=[数据库名]" --data-urlencode "q=SELECT * FROM [表名] ORDER BY time DESC LIMIT [n]" 【查询最新的n条记录】

4. 连续查询【连续做某些操作；比如从旧表做一些统计操作分割出一张表】
    · 查看 show continuous queries
    · 创建 create continuous query [连续查询名] on [数据库名] begin select [某些算子结果]【如 mean(字段)（算平均值）】 into [新表] from [旧表] group by [条件]【如 time(30m)（时间间隔30分钟）】 end
    · 删除 drop continuous query [连续查询名] on [数据库名]
~~~

## 求索

→ 下一代通用型数据库

关系型数据库和SQL使用起来都是比较痛苦的。SQL并不能非常直观地反映出写SQL的人的真实意图。而且在一条SQL执行的时候，如果不是一个数据库专家，你并不了解数据库在背后到底做了多少事情，由此会产生多少副作用。而且将SQL写到程序代码里时也是非常痛苦的，因为现代编辑器可以在写代码的同时就帮你解决许多编程语言的问题，但对于程序代码中的SQL语言块它们却无能为力。<br />
因此，SQL是可以改进的，程序代码和数据库使用相同的语言和工具集；设计一种数据库查询语言，让它与编程语言的工作方法类似；将数据库与程序的内存空间映射起来……等等。<br />
事实上正是这些原因引发了2009年左右出现的一代新型数据库【比如map-reduce数据库、键值型数据库、Javascript数据库等。】，现在事实也证明这些新型数据库比如MongoDB和Redis使用的广泛性，部分原因比如：
~~~
> Redis的设计理念很简单
   为一条数据打上标签，然后就可以用这个标签去获取并操作数据了。数据结构非常丰富，而且数据结构的设计也和程序员们的习惯非常吻合，处理数据的操作正是构建应用程序的基础操作。而且，Redis非常专注于把这些事情做好，并且不会分心去解决别的问题。
> MongoDB的概念也类似
   基本就是数据库应该可以存储嵌套的、结构化的文档，并且可以直接映射为编程语言中使用的数据结构或对象。并且在此之上MongoDB还有另外一个强大的工具：可以直接使用应用得非常广泛的JavaScript来查询数据库。还有，它内置分布式的特性，因此你的业务程序就不必再考虑分片细节了。
~~~
同时代出现的其它NoSQL型数据库由于没有用类似思路去解决相似问题，所以在大潮过后，它们也就慢慢退出历史舞台了。<br />
Baron Schwartz曾细致地讨论过时间序列数据库，曾经论证 **世界就是时间序列** ，而且分享过他认为的时间序列数据库应该满足的需求。在现有的这个类型的数据库产品中，Schwartz认为InfluxDB最有前途，Elasticsearch也不错。
~~~
> InfluxDB
   InfluxDB最近的受关注度在急剧上升，因为它在试图定义“一个原生的基于时间的数据库到底是怎样的”，并试图回答作为一个数据库满足这样的特性是否已经足够，以及在有了这样的特性之后，用户还可能希望再添加些什么功能。定义一款数据库的功能边界很难，但现在看起来InfluxDB做得相当不错。
> ElasticSearch
   ElasticSearch在某些方面提供了时间序列的功能，但它的核心并不在此。它实际上是一个有时间概念的分布式查询引擎。这样做很自然，人们也会相应的有疑问：如果你准备使用一个有时间的非时间序列数据库，那为什么你不干脆使用一个有时间序列功能的关系型数据库？
~~~
**不管怎么样，有一件事情是很肯定的，时间序列非常重要，一定会有非常棒的专用的时间序列数据库来满足这个需求。绝对不能只是满足于某种其它类型的数据库声称：“哦，我们也支持那个功能！”。**

## 用途
~~~
   · 一般用来储存实时数据，配合一套UI界面来展示信息。
~~~
【笔者业务还未用到，以后再深入理解。】

# 总结
毫无疑问，时间这个维度给了人们一个很重要的标识，是一个非常重要的指标，任何事情都可以被贴上时间的标签。通过时间的标签，我们也能很快的对一个对象有了初步的印象或理解【不管理解得准不准确，都能再被检验】，因此，这个维度在数据的存储过程中，每个数据元都可以具备的属性。 <br />
基于这个理解，InfluxDB 拥有一个固定的时间维度的主索引，它采用 **类SQL**【区别于OldSQL】进行交互的，在这个大数据的时代，时间的维度重要性不言而喻，这是值得学习的，完全有可能是下一代的通用型数据库。

<br />
↓
→ 简而言之，**InfluxDB** 是一个基于 **时间序列** 用 **Go语言** 编写的 **分布式数据库**。


**（以上，仅代表个人观点。无论对错，欢迎交流。^_^ ）**
