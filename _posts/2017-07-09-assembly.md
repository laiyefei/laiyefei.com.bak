---
layout: post
title: 基本功之汇编的修炼（一）【虚拟8086模式】
tags: 基础 汇编 底层
categories: 编程语言
note: 基本功之汇编的修炼（一）【虚拟8086模式】
date: 2019-03-28
---

* TOC
{:toc}

# 序言
**x86**对多少人来说是一个熟悉又陌生的名词，现在一般用来称呼32的cpu架构，虽然知道是什么，但是始终有些疑惑。怀着好奇的心，我赶紧谷歌了一下CPU架构的发展，看看为什么要叫这个奇怪的名字。废话不多说，上图<br />
![cpu架构][cpuArchitecture]<br />
从图上，我们可以看出x86原来就是属于一个系列的：像8086，80186，80286，80386，80486可以合计统称x86，那么为什么最早要叫做8086呢，那就要解决为什么最早要叫做4004，怀着好奇的心，笔者找了大量资料，最后发现这可能是跟当时的计算机有关系，当时计算器分为四个部分ROM，RAM，移位寄存器，cpu，这样给个编号不就是4001，4002，4003，4004，没错cpu就属于4004了，况且当时cpu的总线也是4位的。（百度搜不到，搜技术还是谷歌好用。&lt; _ &lt;） 这样，命名就用下来了，最早的微处理器就叫做4004了。然后升级了，4位地址总线变成8位，而且计算机结构划分也出现了问题，当时是80年代，这样干脆叫做8008吧。随后总线位宽又提高，16位，多少带点相似的数字吧，然后就叫做8086。所以就有了8086的命名。之后的升级都是地址位升级，80186，80286，然后位宽变成32位，又刚好80386带3【命名总喜欢带一点数字做关联，好记忆&lt;_&lt;】，这样就形成了**x86体系**。现在讲的x86一般指80386，所以是32位的cpu架构。64位的直接就叫做x64 ![捂脸][wulian]<br />
那么从8086开始是一个变革，本着深入学习汇编的心态，笔者从dos下，虚拟8086汇编开始学起了。<br />
这里普及一下实模式，什么是实模式呢，实模式就是操作系统在启动之前，cpu加电，复位，简单的说就是最真实的模式，操作系统还没接管你的电脑。 操作系统进行一系列措施，这就是保护模式。其实就是管理模式的不一样，来给前者追加实模式的名称。但是windows保护模式里面还提供了虚拟8086模式。这个就相当于8086实模式，笔者就从虚拟8086模式开始学习汇编了&gt; _ &lt;。

# 大纲
我们知道计算机是用电的，最低层的东西当然是电了。![捂脸][wulian] <br />
不扯了，其实计算机通电之后，电脑开关电源将220V交流市电经滤波、整流、开关电路变压、输出滤波后，输出±12V、5V、3.3V等多组直流电，供给电脑设备使用。电压或者电流的每一次变化，都可以用某种关系运算得出某个值，这个值就叫做电平，高电平，低电平代表二进制10。 所以计算机最低层的运算，肯定是二进制运算了，然而，二进制根本反人类，需要将它映射成人类能理解的语言。直接翻译过来的就是汇编语言了，汇编语言指令就是一些二进制直接映射过来的指令，学习意义基本等同于二进制。废话不多说，开始来啃了。

## 工具
这里用的是 [MASM][masm] 工具进行学习。

## 机制
汇编语言源程序 → <span style="color:red">编辑程序</span> → .asm文件 → <span style="color:red">汇编程序MASM</span> → .obj文件 → <span style="color:red">连接程序LINK</span> → .exe文件

## 汇编指令

### 元素

#### 通用寄存器

→ 数据寄存器
数据寄存器共有4个寄存器 **AX**, **BX**, **CX**, **DX**, 用来保存操作数或者运算结果：<br />
~~~
AX 寄存器称为累加器。 使用频率最高，用于算术，逻辑运算以及与外设通信等。
BX 寄存器称为基址寄存器。 常用于存放存储器地址。
CX 寄存器称为计数器。 一般作为循环或者串操作等指令中的隐含计数器。
DX 寄存器称为数据寄存器。 常用来存放双字数据的高16位， 或存放外设端口地址。
~~~

→ 变址和指针寄存器
变址和指针寄存器包括 **SI**，**DI**，**SP**，**BP** 4个16位寄存器， 主要用于存放某个存储单元的偏移地址。
~~~
SI 是源变址寄存器。
DI 是目的变址寄存器，在字符串操作中，SI和DI都具有自动增量或减量的功能。
SP 为堆栈指针寄存器，用于存放当前堆栈段中栈顶的偏移地址。
BP 为基址指针寄存器，用于存放堆栈段中某一存储单元的偏移地址。
~~~

#### 段寄存器
8086 CPU的4个16位的段寄存器分别称为：代码段寄存器**CS**，数据段寄存器**DS**，堆栈段寄存器**SS**，附加数据段寄存器**ES**。
段寄存器用来确定该段在内存中的起始地址。<br />
代码段用来存放程序的指令序列。<br />
**CS**存放代码段的段首址，指令指针寄存器**IP**指示代码段中指令的偏移地址。

#### 指令指针
8086CPU中的指令指针**IP**，他总是保存下一次将要从主存中取出指令的偏移地址，偏移地址的值为该指令到所在段段首址的字节距离。在目标程序运行时，IP的内容由微处理器硬件自动设置，程序不能直接访问IP，但一些指令却可以改变IP的值，如：**转移指令**、**子程序调用指令**。

#### 标志寄存器
8086CPU中有一个很重要的**16**位标志寄存器，它包含**9**个标志位，主要用于保存一条指令执行后，CPU所处状态信息及运算结果的**特征**。
~~~
条件标志：
	1.进位标志CF 进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。  使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。
	2.零标志ZF 零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。
	3.符号标志SF 符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。
	4.溢出标志OF 溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。
	5.奇偶标志PF 奇偶标志PF用于反映运算结果中1的个数的奇偶性。如果1的个数为偶数，则PF的值为1，否则其值为0。利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。
	6.辅助进位标志AF
		在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：
			6.1 在字操作时，发生低字节向高字节进位或借位时；
			6.2 在字节操作时，发生低4位向高4位进位或借位时。
		对以上6个运算结果标志位，在一般编程情况下，标志位CF、ZF、SF和OF的使用频率较高，而标志位PF和AF的使用频率较低。
状态控制标志
	1.方向标志DF
	2.中断允许标志IF
	3.追踪标志TF
~~~

### 格式

→ 指令性

~~~
[标号:] 操作码 [操作数1] [操作数2] ;[注释]
~~~

→ 指示性

~~~
[标识符(名字)] 指示符(伪指令) 表达式
~~~

→ 有关属性

~~~
标号/标识符.属性(三种): 段值SEG；段内偏移量OFFSET；类型(byte/word/dword/near/far ...)
~~~

### 运算符

→ 算术运算符

~~~
加(add,adc):
	add 寄存器，数据		比如：add ax,8
	add 寄存器，寄存器	比如：add ax,bx
	add 寄存器，内存单元	比如：add ax,[0]
	add 内存单元，寄存器	比如：add [0],ax
	adc 是带进位加法指令，利用了CF标志位上记录的进位值。比如 : adc ax,1（相当于 (ax) = (ax) + 1 +CF）
减(sub,sbb):
	sub 寄存器，数据	比如：sub ax,9
	sub 寄存器，寄存器	比如：sub ax,bx
	sub 寄存器，内存单元	比如：sub ax,[0]
	sub 内存单元，寄存器	比如：sub [0],ax
	sbb是带借位减法指令，利用了CF标志位上记录的借位值。比如 : sbb ax,1（相当于 (ax) = (ax) - 1 - CF）
乘(mul):
	·两个数是8位
	    一个数放在al，
	    另一个数放在8位寄存器或者内存单元中，
	    结果：放在ax中。
	    比如：mul byte ptr ds:[0]
	    含义：(ax) = (al) * ((ds)*16+0)
	·两个数是16位
	    一个数放在ax，
	    另一个数放在16位寄存器中或内存单元中，
	    结果：低位放在ax，高位放在dx。
	    比如：mul word ptr [bx+si+8]
	    含义：(ax) = (ax) * ((ds)*16+(bx)+(si)+8)结果的低16位，
	   		  (dx) = (ax) * ((ds)*16+(bx)+(si)+8)结果的高16位。    
除(div):
	·被除数为16位，除数为8位
	    被除数放在ax，
	    除数放在寄存器或内存单元，
	    结果：al存储商，ah存储余数。
	    比如：div byte ptr ds:[0]
	    含义：(al) = (ax) / ((ds) * 16 + 0的商，
	          (ah) = (ax) / ((ds) * 16 + 0的余数。
	·被除数为32位，除数为16位
		被除数高16位放在dx，低16位放在ax，
		除数放在寄存器或内存单元，
		结果：ax存储商，dx存储余数。
		比如：div word ptr es:[0]
		含义：(ax) = ((dx) * 10000H + (ax)) / ((es) * 16 + 0 )的商，
		       (dx) = ((dx) * 10000H + (ax)) / ((es) * 16 + 0)的余数。
~~~

→ 逻辑运算符

~~~
AND 与运算.
or 或运算.
XOR 异或运算.
NOT 取反.
~~~
TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果).

~~~
SHL 逻辑左移.
SAL 算术左移.(=SHL)
SHR 逻辑右移.( 每位右移, 低位进 CF, 高位补 0)
SAR 算术右移.(每位右移, 低位进 CF, 高位不变)
ROL 循环左移.
ROR 循环右移.
RCL 通过进位的循环左移.
RCR 通过进位的循环右移.
~~~
以上八种移位指令,其移位次数可达255次.
移位一次时, 可直接用操作码. 如 SHL AX,1.
移位>1次时, 则由寄存器CL给出移位次数.
如 MOV CL,04

## 牛刀小试

当然是输出那句伟大的话：“helloworld！”

### 编写asm
~~~
DATAS SEGMENT
	STARING DB 'Hello World !', 13, 10, '$'
DATAS ENDS

CODES SEGMENT
	ASSUME CS:CODES, DS:DATAS

START:
	MOV AX, DATAS
	MOV DS, AX
	LEA DX, STARING
	MOV AH, 9
	INT 21H
	MOV AH, 4CH
	INT 21H
CODES ENDS

END START
~~~

### 汇编.asm

![汇编成obj][masm2obj]

### 连接.obj

![obj连接成exe][obj2exe]

### 运行.exe

![运行exe][runExe]  

&gt; _ &lt; 至此，最简单的8086汇编程序终于完成了。


**（以上，仅代表个人观点。无论对错，欢迎交流。^_^ ）**

[masm]: {{ "https://github.com/sherlock-help/Tools/tree/master/assembly/MASM" }}
[masm2obj]: {{ "/2017-07-11-masm2obj.png" | prepend: site.imgrepo }}
[obj2exe]: {{ "/2017-07-11-obj2exe.png" | prepend: site.imgrepo }}
[runExe]: {{ "/2017-07-11-runExe.png" | prepend: site.imgrepo }}
[cpuArchitecture]: {{ "/2017-07-11-cpuArchitecture.jpg" | prepend: site.imgrepo }}
[wulian]: {{ "/2017-07-11-wulian.png" | prepend: site.imgrepo }}
